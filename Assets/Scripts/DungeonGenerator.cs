using UnityEngine;
using UnityEngine.SceneManagement;
using System.Collections;
using System;

//Unity already has a Vector2 class which uses floats
//This struct was created to avoid int/float casting
public struct IntVector2
{
	public int x;
	public int y;

	public IntVector2(int _x, int _y)
	{
		x = _x;
		y = _y;
	}
}

public class DungeonGenerator : MonoBehaviour
{
	//Exposed vars (exposed in editor)
	public int mazeWidth;
	public int mazeHeight;
	public bool spawnTreasure;
	public bool spawnMonsters;
	public bool generateOnStart;
	public GameObject floorPrefab;
	public GameObject wallPrefab;
	public GameObject staircasePrefab;
	public GameObject monsterPrefab;
	public GameObject treasurePrefab;
	public GameObject flarePrefab;

	//Private constants
	const string objectTag = "DungeonGenerator";
	const string playerTag = "Player";
	const float treasureChance = 0.5f;
	const float monsterChance = 0.2f;

	//Private vars
	float tileSize;
	bool[,] wasVisited = null;
	GameObject player;
	Vector3 playerStartPos;

	private void Start()
	{
		if(generateOnStart)
		{
			GenerateDungeon();
		}

		player = GameObject.FindWithTag(playerTag);
		playerStartPos = player.transform.position;
	}

	private void Update()
	{
		if(Input.GetKeyDown(KeyCode.Escape))
		{
			//On esc press, quit application
			Application.Quit();
			return;
		}

		if(Input.GetKeyDown(KeyCode.G))
		{
			//On G press, generate new dungeon
			GenerateDungeon();
		}

		if(Input.GetKeyDown(KeyCode.T) || player.transform.position.y < -5.0f)
		{
			//On T press, or if player position is too low (player fell out of world), teleport player back to starting position
			player.transform.position = playerStartPos;
		}
	}

	//Needs to be public, so it can be called in the editor by DungeonGeneratorEditor
	public void GenerateDungeon()
	{
		if(floorPrefab == null ||
			wallPrefab == null ||
			staircasePrefab == null ||
			flarePrefab == null ||
			(spawnMonsters && monsterPrefab == null) ||
			(spawnTreasure && treasurePrefab == null))
		{
			Debug.LogError("Cannot generate dungeon - one or more prefabs is invalid");
			return;
		}

		DestroyOldObjects();

		GenerateMaze();
	}

	//Destroys all game objects with our tag (ie objects generated by the DungeonGenerator class)
	private void DestroyOldObjects()
	{
		GameObject[] oldDungeonObjects = GameObject.FindGameObjectsWithTag(objectTag);
		foreach(GameObject curr in oldDungeonObjects)
		{
			DestroyImmediate(curr);
		}
	}
		
	private void CreateObject(GameObject prefab, Vector3 pos, Quaternion rot)
	{
		GameObject result = Instantiate(prefab, pos, rot) as GameObject;
		result.tag = objectTag;
	}

	//Randomly decides whether or not to create an object
	//chance [0.0, 1.0]
	private void RandomCreateObject(GameObject prefab, Vector3 pos, Quaternion rot, float chance)
	{
		if(UnityEngine.Random.Range(0.0f, 1.0f) < chance)
		{
			CreateObject(prefab, pos, rot);
		}
	}

	private void GenerateMaze()
	{
		//Multiply by 10 because the floor is a plane, and in Unity planes have 10x scale (ie a plane of scale 1 is actually 10 units long)
		tileSize = floorPrefab.transform.localScale.x * 10.0f;

		//Reset wasVisited
		wasVisited = new bool[mazeWidth, mazeHeight];

		//Maze generation algorithm:
		//1) Choose a starting tile (in my testing, starting in the middle of the grid produced more interesting mazes).
		//2) Check all neighbors (left, right, up, down). If neighbor has already been visited, build a wall.
		//3) Visit all unvisited neighbors in random order and recursively repeat steps 2-3 (depth first).
		VisitTile(new IntVector2(mazeWidth / 2, mazeHeight / 2), new IntVector2(-1, -1));

		//Add staircases at beginning and end
		CreateStaircases();

		//Add flare at end of maze
		CreateObject(flarePrefab, new Vector3((mazeWidth - 1) * tileSize, 10, (mazeHeight - 1) * tileSize), Quaternion.identity);
	}

	//Visits the tile at this index, and recursively visits neighboring tiles
	private void VisitTile(IntVector2 pos, IntVector2 prev)
	{
		//Mark as visited
		wasVisited[pos.x, pos.y] = true;

		//Create floor
		CreateObject(floorPrefab, new Vector3(pos.x * tileSize, 0, pos.y * tileSize), Quaternion.identity);

		//Preprocess all four neighbors (left, right, down, up)
		ArrayList neighbors = new ArrayList();
		PreProcessNeighbor(pos, new IntVector2(pos.x - 1, pos.y), prev, neighbors);
		PreProcessNeighbor(pos, new IntVector2(pos.x + 1, pos.y), prev, neighbors);
		PreProcessNeighbor(pos, new IntVector2(pos.x, pos.y - 1), prev, neighbors);
		PreProcessNeighbor(pos, new IntVector2(pos.x, pos.y + 1), prev, neighbors);

		if((pos.x != 0 || pos.y != 0) && (pos.x != mazeWidth - 1 || pos.y != mazeHeight - 1))
		{
			//Make sure we're not on the first or last tile
			if(neighbors.Count == 0)
			{
				if(spawnTreasure)
				{
					//We are at a dead end, try to spawn treasure
					RandomCreateObject(treasurePrefab, new Vector3(pos.x * tileSize, 0, pos.y * tileSize), Quaternion.identity, treasureChance);
				}
			}
			else if(spawnMonsters)
			{
				//Try to spawn a monster
				RandomCreateObject(monsterPrefab, new Vector3(pos.x * tileSize, 0, pos.y * tileSize), Quaternion.identity, monsterChance);
			}
		}

		while(neighbors.Count > 0)
		{
			//While neighbor list is not empty, recursively visit neighbors in random order
			int index = UnityEngine.Random.Range(0, neighbors.Count);
			IntVector2 neighbor = (IntVector2)neighbors[index];
			neighbors.RemoveAt(index);

			//We have to check wasVisited again because the neighbor could have been visited by another recursive call
			if(!wasVisited[neighbor.x, neighbor.y])
			{
				VisitTile(neighbor, pos);
			}
		}
	}

	private void PreProcessNeighbor(IntVector2 pos, IntVector2 neighbor, IntVector2 prev, ArrayList neighbors)
	{
		if(neighbor.x == prev.x && neighbor.y == prev.y)
		{
			//This is where we just came from, so ignore this neighbor
			return;
		}

		if(OutOfBounds(neighbor) || wasVisited[neighbor.x, neighbor.y])
		{
			//If the neighbor is out of bounds, or if it was already visited, then we need to build a wall
			CreateWall(pos, neighbor);
		}
		else
		{
			//Otherwise add to list of neighbors to be visited
			neighbors.Add(neighbor);
		}
	}

	//Creates a wall which will separate the two adjacent tiles at pos1 and pos2
	private void CreateWall(IntVector2 pos1, IntVector2 pos2)
	{
		Quaternion rot = Quaternion.identity;
		if(pos1.x != pos2.x)
		{
			//The wall needs to be rotated 90 degrees if we are building a wall that should separate left/right neighbors
			rot = Quaternion.Euler(new Vector3(0, 90, 0));
		}
		Vector3 pos = new Vector3();
		pos.x = ((pos1.x + pos2.x) / 2.0f) * tileSize;
		pos.y = 0;
		pos.z = ((pos1.y + pos2.y) / 2.0f) * tileSize;

		CreateObject(wallPrefab, pos, rot);
	}

	private void CreateStaircases()
	{
		//Starting staircase
		CreateObject(staircasePrefab, new Vector3(0, 0, 0), Quaternion.identity);

		//Ending staircase
		CreateObject(staircasePrefab, new Vector3((mazeWidth - 1) * tileSize, 0, (mazeHeight - 1) * tileSize), Quaternion.Euler(new Vector3(0, 180, 0)));
	}

	private bool OutOfBounds(IntVector2 pos)
	{
		if(pos.x < 0 ||
			pos.y < 0 ||
			pos.x >= mazeWidth ||
			pos.y >= mazeHeight)
		{
			return true;
		}
		return false;
	}
}